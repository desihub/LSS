'''Original version written by Anand Raichoor''''''test'''# need to run before:# source /global/cfs/cdirs/desi/software/desi_environment.sh masterimport osimport numpy as npimport fitsioimport astropy.io.fits as fitsimport raichoorlibimport sysfrom desimodel.focalplane.geometry import get_tile_radius_degfrom desitarget.io import read_targets_in_tilesfrom desitarget.mtl import make_mtlimport multiprocessingfrom argparse import ArgumentParser# reading argumentsparser = ArgumentParser(allow_abbrev=True)parser.add_argument('--dr',           help='legacypipe dr (e.g. dr8)',type=str,default=None,metavar='DR')parser.add_argument('--dtver',        help='desitarget version (e.g. 0.39.0)',type=str,default=None,metavar='DTVER')parser.add_argument('--targ',         help='tiles,science,std,sky,rand',type=str,default=None,metavar='TARG')parser.add_argument('--radec'  ,      help='radec boundaries for tile centres (e.g.: 0,200,0,30)',type=str,default=None,metavar='RADEC')parser.add_argument('--randdens',     help='random density (/deg2)',type=float,default=None,metavar='RANDDENS')parser.add_argument('--obsconds',     help='observing conditions (e.g.: dark,gray)',type=str,default=None,metavar='OBSCONDS')parser.add_argument('--outfits',      help='output fits file',type=str,default=None,metavar='OUTFITS')parser.add_argument('--priority_init',help='priority_init for rand',type=int,default=None,metavar='PRIORITY_INIT')parser.add_argument('--numobs_init',  help='numobs_init for rand',type=int,default=None,metavar='NUMOBS_INIT')parser.add_argument('--desi_target',  help='desi_target (bitwise) for science/rand (e.g.: 0,1,2)',type=str,default=None,metavar='DESI_TARGET')parser.add_argument('--lyafrac',      help='fraction of qso which are lya (0.20 is reasonable)',type=float,default=0.,metavar='LYAFRAC')args   = parser.parse_args()for kwargs in args._get_kwargs():    print(kwargs)nproc = multiprocessing.cpu_count() // 2# settingstfn  = os.getenv('DESIMODEL')+'/data/footprint/desi-tiles.fits'trad = get_tile_radius_deg() # maximum radius in degrees covered by the outermost positionerif (args.targ=='sky'):    drdir= '/global/cfs/projectdirs/desi/target/catalogs/'+args.dr+'/'+args.dtver+'/skies/'    keys = ['TARGETID','RA','DEC','DESI_TARGET','BGS_TARGET','MWS_TARGET','SUBPRIORITY',             'BRICKNAME','BRICKID','BRICK_OBJID','FIBERFLUX_G','FIBERFLUX_R','FIBERFLUX_Z',            'FIBERFLUX_IVAR_G','FIBERFLUX_IVAR_R','FIBERFLUX_IVAR_Z','OBSCONDITIONS']    hdu  = fits.open(drdir+'skies-'+args.dr+'-hp-0.fits')    fmts = [hdu[1].columns[key].format for key in keys]if (args.targ in ['science','std','rand']):    drdir= '/global/cfs/projectdirs/desi/target/catalogs/'+args.dr+'/'+args.dtver+'/targets/main/resolve/dark/'    keys = [        'TARGETID','RA','DEC','RA_IVAR','DEC_IVAR','PMRA','PMDEC','PMRA_IVAR','PMDEC_IVAR',        'DESI_TARGET','BGS_TARGET','MWS_TARGET','SUBPRIORITY',        'BRICKNAME','BRICKID','BRICK_OBJID','PRIORITY_INIT','NUMOBS_INIT'            ]    for f in ['G','R','Z','W1','W2']:        keys += ['FLUX_'+f,'MW_TRANSMISSION_'+f]    keys += ['MASKBITS','REF_CAT','MORPHTYPE','FIBERFLUX_G','FIBERFLUX_R','FIBERFLUX_Z']    hdu  = fits.open(drdir+'targets-'+args.dr+'-hp-0.fits')    fmts = [hdu[1].columns[key].format for key in keys]if (args.dr=='dr8'):    randfn = '/global/cfs/projectdirs/desi/target/catalogs/dr8/0.31.0/randoms/randoms-allsky-dr8-0.31.0-1.fits'else:    sys.exit('wrong args.dr!')# desi tilesthdu  = fits.open(tfn)tiles = thdu[1].data## in desi + radeckeep  = (tiles['in_desi']==1)ramin,ramax,decmin,decmax = [float(x) for x in args.radec.split(',')]if (ramax<ramin):    keep &= ((tiles['ra']>ramin) | (tiles['ra']<ramax))else:    keep &= (tiles['ra']>ramin) & (tiles['ra']<ramax)keep &= (tiles['dec']>decmin) & (tiles['dec']<decmax)tiles = tiles[keep]## observing conditionskeep = np.zeros(len(tiles),dtype=bool)for obscond in args.obsconds.split(','):    keep |= (tiles['program'].lower()==obscond.lower())##tiles   = tiles[keep]passids = np.unique(tiles['pass'])npass   = len(passids)for p in passids:    print('pass = '+str(p)+' -> '+str((tiles['pass']==p).sum())+' tiles')# tilesif (args.targ=='tiles'):    #    for p in passids:        keep    = (tiles['pass']==p)        collist = []        for key,fmt in zip(thdu[1].columns.names,thdu[1].columns.formats):            collist.append(fits.Column(name=key,format=fmt,array=tiles[key][keep]))        hdu  = fits.BinTableHDU.from_columns(fits.ColDefs(collist))        hdu.writeto(args.outfits.replace('.fits','-pass'+str(p)+'.fits'),overwrite=True) else:    # randoms    if (args.targ=='random'):        #        adm_dens  = fits.getheader(randfn,1)['density']        adm_nrand = fits.getheader(randfn,1)['naxis2']        np.random.seed(12345)        rows      = np.random.choice(adm_nrand,size=int(adm_nrand*args.randdens/float(adm_dens)),replace=False)        rand      = fitsio.read(randfn,rows=rows,columns=['RA','DEC','BRICKNAME'])        ##        rasafe    = 2*trad/np.cos(np.radians(np.max([decmin,decmax])))        decsafe   = 2*trad        if (ramax<ramin):            keep = ((rand['RA']>ramin-rasafe) | (rand['RA']<ramax+rasafe))        else:            keep = (rand['RA']>ramin-rasafe) & (rand['RA']<ramax+rasafe)        keep     &= (rand['DEC']>decmin-decsafe) & (rand['DEC']<decmax+decsafe)        rand     = rand[keep]        ##        data     = {}        for key in keys:            if   (key in ['RA','DEC','BRICKNAME']): data[key] = rand[key].copy()            elif (key=='TARGETID'):                 data[key] = np.arange(len(rand),dtype=int)            elif (key=='SUBPRIORITY'):              data[key] = np.random.uniform(low=0,high=1,size=len(rand))            elif (key=='PRIORITY_INIT'):            data[key] = args.priority_init + np.zeros(len(rand),dtype=int)            elif (key=='NUMOBS_INIT'):              data[key] = args.numobs_init   + np.zeros(len(rand),dtype=int)            elif (key=='DESI_TARGET'):              data[key] = args.desi_target   + np.zeros(len(rand),dtype=int)            else:                                   data[key] = np.zeros(len(rand),dtype=int)    # science/std/sky    else:        data = read_targets_in_tiles(drdir,tiles,columns=keys)        keep = np.zeros(len(data),dtype=bool)        mybs = {}        #mybs['science'] = [0,1,2]    # lrg,elg,qso        mybs['science'] = [int(b) for b in args.desi_target.split(',')]        mybs['std']     = [33,34,35] # std_faint,std_wd,td_bright        mybs['sky']     = [32,36,37] # sky,bad_sky,supp_sky        for b in mybs[args.targ]:            keep[(data['DESI_TARGET'] & 2**b)>0] = True        ## if not science, removing science targets overlap        if (args.targ!='science'):            for b in mybs['science']:                keep[(data['DESI_TARGET'] & 2**b)>0] = False        data = data[keep]        ##=========== hack ================        ## 2 obs. for elgs        #if (args.targ=='science'):        #   tmp = ((data['DESI_TARGET'] & 2**1)>0) & (data['NUMOBS_INIT']==1)        #   data['NUMOBS_INIT'][tmp] = 2        ###================================    collist = []    for key,fmt in zip(keys,fmts):        collist.append(fits.Column(name=key,format=fmt,array=data[key]))    ## passbit    passbit = np.zeros(len(data['RA']),dtype=int)    for p in passids.astype(str):        tmp    = (tiles['pass']==int(p))        keep   = raichoorlib.get_isintile(data['RA'],data['DEC'],tiles['ra'][tmp],tiles['dec'][tmp],trad)        if (args.targ=='rand'):            areap  = keep.sum()/args.randdens            print('pass=',p,'%.0f'%areap+' deg2')        passbit[keep] += 2**int(p)    collist.append(fits.Column(name='passbit',format='I',array=passbit))    ## lya    if (args.targ=='science'):        np.random.seed(12345)        indqso  = np.where((data['DESI_TARGET'] & 2**2)>0)[0]        indlya  = np.random.choice(indqso,size=int(args.lyafrac*len(indqso)),replace=False)        islya   = np.in1d(np.arange(len(data),dtype=int),indlya)        collist.append(fits.Column(name='islya',format='L',array=islya))    ## assignbit    collist.append(fits.Column(name='assignbit',  format='I',array= np.zeros(len(data['RA']),dtype=int)))    ## ar_numobs_done    collist.append(fits.Column(name='ar_numobs_done',format=str(npass)+'I',array= np.zeros((len(data['RA']),npass),dtype=int)))    ##    hdu  = fits.BinTableHDU.from_columns(fits.ColDefs(collist))    hdu.header['radec']    = args.radec    hdu.header['obsconds'] = args.obsconds    if (args.targ=='rand'):        hdu.header['randdens'] = args.randdens    hdu.header['trad']     = trad    ## cutting on tiles footprint    hdu.data               = hdu.data[passbit>0]    hdu.writeto(args.outfits,overwrite=True)    # mtl    if (args.targ!='sky'):        hdu    = fits.open(args.outfits)        my_mtl = make_mtl(hdu[1].data, '|'.join([x.upper() for x in args.obsconds.split(',')]))        my_mtl.write(args.outfits,overwrite=True)        ###=========== hack ================    # djs email [desi-survey 707]    if (args.targ=='science'):        hdu      = fits.open(args.outfits)        iselg    = ((hdu[1].data['DESI_TARGET'] & 2**1)>0)        ## elg, not qso, in pass=0        tmp  = np.where(((hdu[1].data['DESI_TARGET'] & 2**1)>0) &                         ((hdu[1].data['DESI_TARGET'] & 2**2)==0) &                         ((hdu[1].data['passbit'] & 2**0)>0))[0]        tmpg_ind = np.random.choice(tmp,size=int(0.30*iselg.sum()),replace=False) # 30% of all elgs to be gray-only         tmpg           = np.zeros(len(hdu[1].data),dtype=bool)                    # boolean version of tmpg_ind        tmpg[tmpg_ind] = True        tmpd = (iselg) & (~tmpg)                                                  # 70% of all elgs to be dark-only        hdu[1].data['OBSCONDITIONS'][tmpg] -= 2**0 # setting 30% to gray-only        hdu[1].data['OBSCONDITIONS'][tmpd] -= 2**1 # setting 70% to dark-only        hdu.writeto(args.outfits,overwrite=True)    ###================================    