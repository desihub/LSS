'''Original version written by Anand Raichoor'''#!/usr/bin/env python# need to run before:# source /global/cfs/cdirs/desi/software/desi_environment.sh master# fa commands from Ted s notebook:# https://portal.nersc.gov/project/desi/users/kisner/fiberassign/FiberAssignAlgorithms_Part2.htmlimport globimport osimport subprocessimport numpy as npimport astropy.io.fits as fitsimport raichoorlibimport datetimefrom fiberassign.scripts.assign import parse_assign,run_assign_fullfrom fiberassign.scripts.merge import parse_merge,run_mergefrom time import asctimefrom argparse import ArgumentParser# reading argumentsparser = ArgumentParser()parser.add_argument('--rootdir',  help='root directory; all other paths are relative to that',type=str,default=None,metavar='ROOTDIR')parser.add_argument('--passid',   help='pass id (0=gray, 1,2,3,4=dark)',type=int,default=None,metavar='PASSID')parser.add_argument('--rundate',  help='rundate for focalplane (default=2020-01-01T00:00:00)', type=str,default='2020-01-01T00:00:00',metavar='RUNDATE') parser.add_argument('--input',    help='mtl input file',type=str,default=None,metavar='INPUT')parser.add_argument('--std',      help='std input file',type=str,default=None,metavar='STD')parser.add_argument('--sky',      help='sky input file',type=str,default=None,metavar='SKY')parser.add_argument('--output',   help='mtl output file',type=str,default=None,metavar='OUTPUT')parser.add_argument('--fadir',    help='directory for fibre assign files',type=str,default=None,metavar='FADIR')parser.add_argument('--updatelya',help='update numobs_more with islya? (0,1)',type=int,default=0,metavar='UPDATELYA')args   = parser.parse_args()for kwargs in args._get_kwargs():    print(kwargs)# safeif (args.rootdir[-1]!='/'): args.rootdir += '/'if (args.fadir  [-1]!='/'): args.fadir   += '/'# settingsfootprint   = 'inputs/tiles-pass'+str(args.passid)+'.fits'# create folder / cleanif (os.path.isdir(args.rootdir+args.fadir)==False):	os.mkdir(args.rootdir+args.fadir)else:	fns = glob.glob(args.rootdir+args.fadir+'*.fits')	if (len(fns)>0):		for fn in fns:			os.remove(fn)# Run the fba_run and fba_merge commandline entrypointsdef run_assignment(footprint,science,std,sky,fadir,rundate):	opts = [		'--rundate', rundate,		'--overwrite',		'--write_all_targets',		'--footprint', footprint,		'--dir', fadir,		'--targets', science,std,sky	]	print('  Running raw fiber assignment (fba_run)...')	ag = parse_assign(opts)	run_assign_full(ag)	#	opts = [	'--skip_raw',	'--dir', fadir,	'--targets', science,std,sky	]	print('  Merging input target data (fba_merge_results)...')	ag = parse_merge(opts)	run_merge(ag)	#	return# from bindef run_assignment_bin(footprint,science,std,sky,fadir,rundate):	faexec = os.getenv('FIBERASSIGN')+'/bin/fiberassign'	print("{} Launching fiberassign".format(asctime()))	f = open(fadir+'fiberassign.log','a')	p = subprocess.call([faexec, 		'--mtl',  science,		'--stdstar',  std,  		'--sky', sky, 		'--footprint', footprint,		'--rundate',  rundate,		'--outdir',fadir], 		#'--fibstatusfile',  self.fibstatusfile], 	stdout=f)	print("{} Finished fiberassign".format(asctime()))	f.close()	return# Function to update the MTL obs remaining.def update_mtl(science_input,fadir,science_output):	# fiberassign files	fns  = np.sort(glob.glob(fadir+'/fiberassign-??????.fits'))	# science which received a fibre, science available	# std, sky	samples = ['science',     'targets','std',        'sky']	extnames= ['fiberassign', 'targets','fiberassign','fiberassign']	mydict  = {}	myhdu   = {}	for sample in samples:		mydict[sample] = {}		myhdu [sample] = {}	for fn in fns:		print(fn)		hdu    = fits.open(fn)		for sample,extname in zip(samples,extnames):			## initialisation			if (fn==fns[0]):				myhdu[sample]['keys'] = ['tileid'] + hdu[extname].columns.names				myhdu[sample]['fmts'] = ['J']      + hdu[extname].columns.formats				for key in myhdu[sample]['keys']:					mydict[sample][key] = []			## appending			if   (sample=='std'): keep = ((hdu[extname].data['fa_type'] & 2)>0)			elif (sample=='sky'): keep = ((hdu[extname].data['fa_type'] & 4)>0)			else:                 keep = ((hdu[extname].data['fa_type'] & 1)>0)			for key in myhdu[sample]['keys']:				if (key=='tileid'):					mydict[sample][key] += [hdu[1].header['tileid'] for x in range(keep.sum())]				else:					mydict[sample][key] += hdu[extname].data[key][keep].tolist()	## writing	for sample in samples:		collist = []		for key,fmt in zip(myhdu[sample]['keys'],myhdu[sample]['fmts']):			collist.append(fits.Column(name=key,format=fmt,array=mydict[sample][key]))		hdu  = fits.BinTableHDU.from_columns(fits.ColDefs(collist))		hdu.writeto(fadir+'fiberassign-'+sample+'.fits',overwrite=True)	# science which were not available	tids = np.unique(fits.open(fadir+'fiberassign-targets.fits')[1].data['targetid'])	hdu  = fits.open(science_input)	keep = (~np.in1d(hdu[1].data['targetid'],tids))	hdu[1].data = hdu[1].data[keep]	hdu.writeto(fadir+'fiberassign-not-targets.fits',overwrite=True)	# targetids which received a fibre	tids        = np.array(mydict['science']['TARGETID'])	# unique, counting	tids,counts = np.unique(tids,return_counts=True)	# matching with input file tids	hdu         = fits.open(science_input)	inds0,inds1 = raichoorlib.unq_searchsorted(hdu[1].data['TARGETID'],tids)	## updating numobs_more	hdu[1].data['NUMOBS_MORE'][inds0] -= counts[inds1]	## updating assignbit	hdu[1].data['assignbit']  [inds0] += 2**args.passid	## updating ar_numobs_done	hdu[1].data['ar_numobs_done'][inds0,args.passid] = counts[inds1]	## update lya ?	if (args.updatelya==1):		# qso observed in args.passid which are not lya		keep = (((hdu[1].data['DESI_TARGET'] & 2**2)>0) & 				(hdu[1].data['assignbit']==2**args.passid) &				(~hdu[1].data['islya']))		#hdu[1].data['NUMOBS_MORE'][keep] -= 3		hdu[1].data['NUMOBS_MORE'][keep] = 0	# writing output	hdu.writeto(science_output,overwrite=True)	return# runningrun_assignment(	args.rootdir+footprint,#run_assignment_bin(    args.rootdir+footprint,				args.rootdir+args.input,				args.rootdir+args.std,				args.rootdir+args.sky,				args.rootdir+args.fadir,				args.rundate)update_mtl(		args.rootdir+args.input,				args.rootdir+args.fadir,				args.rootdir+args.output)