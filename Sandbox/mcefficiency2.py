#!/usr/bin/env python#DR7 Truth file /global/cscratch1/sd/raichoor/tmpdir/tmp.dr7.41ra44.-1dec0.clean.deep.fitsimport sys,osimport numpy as npimport matplotlib.pyplot as pltfrom pkg_resources import resource_filenamefrom desiutil.log import get_loggerfrom desitarget import cuts#import astropy.io.fits as pyfitsimport fitsioimport healpy as hpimport argparselog = get_logger()def mag2flux(mag) :    return 10**(-0.4*(mag-22.5))def flux2mag(flux) :    mag = -2.5*np.log10(flux*(flux>0)+0.001*(flux<=0)) + 22.5    mag[(flux<=0)] = 0.    return magdef prof(x,y,bins) :    h0,bins=np.histogram(x,bins=bins)    hx,bins=np.histogram(x,bins=bins,weights=x)    hy,bins=np.histogram(x,bins=bins,weights=y)    hy2,bins=np.histogram(x,bins=bins,weights=y**2)    ii=h0>2    mx=hx[ii]/h0[ii]    my=hy[ii]/h0[ii]    var=hy2[ii]/h0[ii]-my**2    ey=np.sqrt(var*(var>0))/np.sqrt(h0[ii])    return mx,my,eydef colorplot(ra,dec,z,vmin=None,vmax=None) :    nbins=300    raoffset=80.    rap=(ra+raoffset)%360    h0,xbins,ybins = np.histogram2d(rap,dec,bins=nbins)    hz,xbins,ybins = np.histogram2d(rap,dec,bins=nbins,weights=z*(z>=0))    mz=hz/(h0+(h0==0))*(h0>0)    plt.imshow(mz.T,origin=0,extent=(xbins[0]-raoffset,xbins[-1]-raoffset,ybins[0],ybins[-1]),aspect="auto",vmin=vmin,vmax=vmax)    plt.colorbar()######################################################################################################parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)parser.add_argument("-i","--infile", type=str, required=True, help="input pixweight")parser.add_argument("-o","--outfile", type=str, default=None, required=False,  help="output pixweight")parser.add_argument("-t","--truth", type=str,  help="input catalog of magnitudes, deep DES for instance")parser.add_argument("--nstars", type=int, default=None, required=False, help="number of true stars to use")parser.add_argument("--npix", type=int, default=None, required=False, help="number of pixels to look at")args = parser.parse_args()target="ELG"if target == 'LRG':    colorcuts_function = cuts.isLRG_colorselif target == 'ELG':    colorcuts_function = cuts.isELG_colorselif target == 'QSO':    colorcuts_function = cuts.isQSO_colorselse:    colorcuts_function = Nonetruth  = fitsio.read(args.truth,1)print(truth.dtype.names)jj=(truth["flux_g_dered"]>0)&(truth["flux_r_dered"]>0)&(truth["flux_z_dered"]>0)&(truth["flux_g_dered"]>10**(-0.4*(24.5-22.5)))truth = truth[:][jj]nstars = truth.sizeif args.nstars is not None :    if args.nstars < nstars :        jj=(np.random.uniform(size=args.nstars)*nstars).astype(int)        truth = truth[:][jj]        nstars = truth.size"""java -jar ~/software/stilts.jar tpipe in=/global/project/projectdirs/cosmo/data/legacysurvey/dr7/sweep/7.1/sweep-040m005-050p000.fits ifmt=fits cmd='select "ra>41 && ra<44 && dec>-1 && dec<0 && allmask_g==0 && allmask_r==0 && allmask_z==0 && !brightstarinblob && galdepth_g>4000 && galdepth_r>2000 && galdepth_z>500"' cmd='addcol g "22.5-2.5*log10(flux_g/mw_transmission_g)"' cmd='addcol r "22.5-2.5*log10(flux_r/mw_transmission_r)"' cmd='addcol z "22.5-2.5*log10(flux_z/mw_transmission_z)"' cmd='addcol w1 "22.5-2.5*log10(flux_w1/mw_transmission_w1)"' cmd='addcol w2 "22.5-2.5*log10(flux_w2/mw_transmission_w2)"' cmd='keepcols "brickname objid type ra dec g r z w1 w2 galdepth_g galdepth_r galdepth_z"' out=tmpdir/tmp.dr7.41ra44.-1dec0.clean.deep.fits ofmt=fits""""""gmag  = truth["g"]rmag   = truth["r"]zmag   = truth["z"]gflux  = 10**(-0.4*(gmag-22.5))rflux  = 10**(-0.4*(rmag-22.5))zflux  = 10**(-0.4*(zmag-22.5))"""gflux = truth["flux_g_dered"]rflux = truth["flux_r_dered"]zflux = truth["flux_z_dered"]w1flux = np.zeros(gflux.shape)w2flux = np.zeros(gflux.shape)gmag  = flux2mag(gflux)rmag  = flux2mag(rflux)zmag  = flux2mag(zflux)true_selection = colorcuts_function(gflux=gflux, rflux=rflux, zflux=zflux, w1flux=w1flux, w2flux=w2flux, south=True)star_selection = ((gmag-rmag)>(1.5*(rmag-zmag)+0.0))&((gmag-rmag)<(1.5*(rmag-zmag)+0.4))&((gmag-rmag)>(-1.5*(rmag-zmag)+0.3))&((gmag-rmag)<(-1.5*(rmag-zmag)+2.0))true_mean=np.mean(true_selection.astype(float))plt.figure("model")plt.subplot(1,2,1)plt.plot(rmag-zmag,gmag-rmag,".",alpha=0.2,color="gray")plt.plot((rmag-zmag)[true_selection],(gmag-rmag)[true_selection],".",alpha=1,color="green")plt.plot((rmag-zmag)[star_selection],(gmag-rmag)[star_selection],".",alpha=1,color="red")plt.xlabel("rz")plt.ylabel("gr")plt.subplot(1,2,2)plt.hist(gmag,bins=40,color="gray")plt.hist(gmag[true_selection],bins=40,color="green")plt.xlabel("gmag")#plt.show()#sys.exit(12)seed = 1rand = np.random.RandomState(seed)pix,header=fitsio.read(args.infile,header=True)HPXNSIDE=header["HPXNSIDE"]print(pix.dtype.names)print("number of pixels=",pix.size)ii=np.where((pix["GALDEPTH_G"]>0)&(pix["GALDEPTH_R"]>0)&(pix["GALDEPTH_Z"]>0)&(pix["FRACAREA"]>0.8))[0]npix=ii.sizeif args.npix :    jj=(rand.uniform(size=args.npix)*ii.size).astype(int)    ii=ii[jj]    npix=ii.size    depth_keyword="PSFDEPTH"gdepth=-2.5*np.log10(5/np.sqrt(pix[depth_keyword+"_G"][ii]))+22.5rdepth=-2.5*np.log10(5/np.sqrt(pix[depth_keyword+"_R"][ii]))+22.5zdepth=-2.5*np.log10(5/np.sqrt(pix[depth_keyword+"_Z"][ii]))+22.5fracarea=pix["FRACAREA"][ii]target_density=pix[target][ii]star_density=pix["STARDENS"][ii]ebv=pix["EBV"][ii]print("healpix -> ra,dec")theta, phi = hp.pix2ang(HPXNSIDE, pix["HPXPIXEL"], nest=True)ra, dec = np.degrees(phi), 90 - np.degrees(theta)#plt.figure()#i=pix["EBV"]>=0#i=pix["GALDEPTH_G"]>0#colorplot(ra[i],dec[i],pix["EBV"][i],vmax=0.2)#colorplot(ra[i],dec[i],-2.5*np.log10(5/np.sqrt(pix["GALDEPTH_G"][i]))+22.5,vmin=23)#colorplot(ra[i],dec[i],pix["FRACAREA"][i])#plt.show()#sys.exit(12)efficiency=np.zeros(npix)efficiency_of_true_elgs=np.zeros(npix)efficiency_of_stars=np.zeros(npix)R_G=3.63476336 # for R_V=3.1 , ext_odonnell , at effective wavelengthR_R=2.55808601R_Z=1.43322196# see http://legacysurvey.org/dr7/catalogs/gsigma=1./np.sqrt(pix[depth_keyword+"_G"][ii])rsigma=1./np.sqrt(pix[depth_keyword+"_R"][ii])zsigma=1./np.sqrt(pix[depth_keyword+"_Z"][ii])# keep same random numbergrand = np.random.normal(size=gflux.shape)rrand = np.random.normal(size=rflux.shape)zrand = np.random.normal(size=zflux.shape)for j,i in enumerate(ii) : # loop on sky pixels    if j%500==0 : print("{}/{}, {:3.2f}%".format(j,ii.size,float(j)/ii.size*100.))        gsig = gsigma[j]*10**(0.4*R_G*pix["EBV"][i])    rsig = rsigma[j]*10**(0.4*R_R*pix["EBV"][i])    zsig = zsigma[j]*10**(0.4*R_Z*pix["EBV"][i])        mgflux = gflux + grand*gsig    mrflux = rflux + rrand*rsig    mzflux = zflux + zrand*zsig        combined_snr = np.sqrt(mgflux**2/gsig**2+mrflux**2/rsig**2+mzflux**2/zsig**2)    selection = colorcuts_function(gflux=mgflux, rflux=mrflux, zflux=mzflux, w1flux=w1flux, w2flux=w2flux, south=True) * ( combined_snr > 6 ) * ( gflux > 4*gsig ) * ( rflux > 3.5*rsig ) * ( zflux > 2.*zsig )            efficiency[j]=np.mean(selection.astype(float))/true_mean    efficiency_of_true_elgs[j]=np.mean((true_selection*selection).astype(float))/true_mean    efficiency_of_stars[j]=np.mean((star_selection*selection).astype(float))/true_mean    if 0 :    plt.figure()    plt.plot(efficiency,target_density,".")    plt.xlabel("efficiency")if 0 :    plt.figure()    plt.plot(ebv,gdepth,".")    plt.xlabel("ebv")    plt.ylabel("gdepth")coef = -0.23scaled_coef = 0.for stuff,label in zip([star_density,gdepth,rdepth,zdepth,ebv],["stardens","g depth ({} 5 sigma)".format(depth_keyword),"r depth ({} 5 sigma)".format(depth_keyword),"z depth ({} 5 sigma)".format(depth_keyword),"EBV"]) :    plt.figure(label)    plt.plot(stuff,target_density,".",color="gray",alpha=0.1)    x,y,e=prof(stuff,target_density,bins=40)    plt.errorbar(x,y,e,fmt="o",color="k",label="data")    if label=="stardens" :        c=np.polyfit(x,y,1)        print("coef=",c)        coef=c[0]        pol=np.poly1d(c)        plt.plot(x,pol(x),"-",color="black")        scale = np.median(target_density-coef*star_density)/np.median(efficiency)        scale = np.median(target_density)/np.median(efficiency+coef/scale*star_density)        scaled_coef = coef/scale        x,y,e=prof(stuff,scale*(efficiency+scaled_coef*star_density),bins=40)    plt.errorbar(x,y,e,fmt="o",color="blue",label="targets")    x,y,e=prof(stuff,scale*(efficiency_of_true_elgs+(efficiency_of_true_elgs/efficiency)*scaled_coef*star_density),bins=40)    plt.errorbar(x,y,e,fmt="o",color="green",label="original targets")    x,y,e=prof(stuff,scale*(efficiency_of_stars+(efficiency_of_stars/efficiency)*scaled_coef*star_density),bins=40)    plt.errorbar(x,y,e,fmt="o",color="red",label="selected stars")    plt.xlabel(label)    plt.ylabel(target+" density")    plt.grid()    plt.legend()efficiency_of_true_elgs += (efficiency_of_true_elgs/efficiency)*scaled_coef*star_densityefficiency_of_stars     += (efficiency_of_stars/efficiency)*scaled_coef*star_densityefficiency              += scaled_coef*star_densityif args.outfile :    print("writing",args.outfile)    ndtype=np.dtype( pix.dtype.descr + [ ("ELGEFF", "f8"),("STARCONT", "f8")])    newpix=np.zeros(pix.shape,dtype=ndtype)    for k in pix.dtype.names : newpix[k]=pix[k]    newpix["ELGEFF"][ii]=efficiency/np.max(efficiency) # normalized to 1    newpix["STARCONT"][ii]=efficiency_of_stars/np.max(efficiency) # normalized to 1        fitsio.write(args.outfile, newpix, clobber=True)    print("done")    plt.show()sys.exit(12)